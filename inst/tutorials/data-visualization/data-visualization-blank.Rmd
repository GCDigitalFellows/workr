# Data visualization in R

## Introduction

The goal of this workshop is to teach you how to produce useful graphics with `ggplot2` as quickly as possible. You'll learn the basics of `ggplot()` along with some useful "recipes" to make the most important plots. `ggplot()` allows you to make complex plots with just a few lines of code because it's based on a rich underlying theory, the grammar of graphics. 

In this workshop you'll learn:

* The basics of the grammar of graphics
* About the `mpg` dataset included with `ggplot2`
* The three key components of every plot: data, aesthetics and geoms
* How to add additional variables to a plot with aesthetics
* How to display additional categorical variables in a plot using small multiples created by facetting
* A variety of different geoms that you can use to create different types of plots
* How to modify the axes
* Things you can do with a plot object other than display it, like save it to disk

The content of much of this tutorial is taken from the book ["ggplot2: Elegant Graphics for Data Analysis"](https://ggplot2-book.org/) by Hadley Wickham.

## The grammar of graphics

A good grammer (1) allows us to gain insight into the composition of complicated graphics, (2) reveals unexpected connections between seemingly different graphics, and (3) provides a strong foundation for understanding a diverse range of graphics. According to the layered grammar of graphics implemented in `ggplot2`, all plots are composed of:

- **Data** that you want to visualise and a set of aesthetic **mapping**s describing how variables in the data are mapped to aesthetic attributes that you can perceive.
- **Layers** made up of geometric elements and statistical transformation. Geometric objects, **geom**s for short, represent what you actually see on the plot: points, lines, polygons, etc. Statistical transformations,  **stat**s for short, summarise data in many useful ways. For example, binning and counting observations to create a histogram, or summarising a 2d relationship with a linear model. 
- The **scale**s map values in the data space to values in an aesthetic space, whether it be color, or size, or shape. Scales draw a legend or axes, which provide an inverse mapping to make it possible to read the original data values from the plot.
- A coordinate system, **coord** for short, describes how data coordinates are mapped to the plane of the graphic. It also provides axes and gridlines to make it possible to read the graph. We normally use a Cartesian coordinate system, but a number of others are available, including polar coordinates and map projections.
- A **facet**ing specification describes how to break up the data into subsets and how to display those subsets as small multiples. This is also known as conditioning or latticing/trellising.
- A **theme** which controls the finer points of display, like the font size and background color. While the defaults in `ggplot2` have been chosen with care, you may need to consult other references to create an attractive plot.

These are the fundamental principles (i.e., grammar) that govern how graphics are constructed in `ggplot2`. Some of this might not quite make sense just yet, but should become clearer as we work through some examples. 

## Fuel economy data

In this workshop, we'll mostly use one data set that's bundled with `ggplot2`: `mpg`. It includes information about the fuel economy of popular car models in 1999 and 2008, collected by the US Environmental Protection Agency, <http://fueleconomy.gov>. You can access the data by loading `ggplot2`:

```{r}

```

The variables are mostly self-explanatory:

* `cty` and `hwy` record miles per gallon (mpg) for city and highway driving.

* `displ` is the engine displacement in litres.

* `drv` is the drivetrain: front wheel (f), rear wheel (r) or four wheel (4).

* `model` is the model of car. There are 38 models, selected because they had a new edition every year between 1999 and 2008.
   
* `class` is a categorical variable describing the "type" of car: two seater, SUV, compact, etc.

This dataset suggests many interesting questions. How are engine size and fuel economy related? Do certain manufacturers care more about fuel economy than others? Has fuel economy improved in the last ten years? We will try to answer some of these questions, and in the process learn how to create some basic plots with `ggplot2`.

## Key components of a plot

Every `ggplot2` plot has three key components: 

1.  __data__,

1. A set of __aesthetic mappings__ between variables in the data and 
   visual properties, and 

1. At least one layer which describes how to render each observation. Layers
   are usually created with a __geom__ function.

Here's a simple example:

```{r}

```

This produces a scatterplot defined by:

1. Data: `mpg`.
2. Aesthetic mapping: engine size mapped to x position, fuel economy to y
   position.
3. Layer: points.

Pay attention to the structure of this function call: data and aesthetic mappings are supplied in `ggplot()`, then layers are added on with `+`. This is an important pattern, and as you learn more about `ggplot2` you'll construct increasingly sophisticated plots by adding on more types of components.

Almost every plot maps a variable to `x` and `y`, so naming these aesthetics is tedious, so the first two unnamed arguments to `aes()` will be mapped to `x` and `y`. This means that the following code is identical to the example above:

```{r}

```

I'll stick to that style throughout the workshop, so don't forget that the first two arguments to `aes()` are `x` and `y`. Note that I've put each command on a new line. I recommend doing this in your own code, so it's easy to scan a plot specification and see exactly what's there. In this workshop, I'll sometimes use just one line per plot, because it makes it easier to see the differences between plot variations.

The plot shows a strong correlation: as the engine size gets bigger, the fuel economy gets worse. There are also some interesting outliers: some cars with large engines get higher fuel economy than average. What sort of cars do you think they are?

### Exercise

Describe the data, aesthetic mappings and layers used for each of the following plots. You'll need to guess a little because you haven't seen all the datasets and functions yet, but use your common sense! See if you can predict what the plot will look like before running the code in the code block below.
    
    1. `ggplot(mpg, aes(cty, hwy)) + geom_point()`
    2. `ggplot(diamonds, aes(carat, price)) + geom_point()`
    3. `ggplot(economics, aes(date, unemploy)) + geom_line()`
    4. `ggplot(mpg, aes(cty)) + geom_histogram()`
    
```{r}

```

## Color, size, shape and other aesthetic attributes

To add additional variables to a plot, we can use other aesthetics like color, shape, and size (note: `ggplot2` accepts both American and British spellings). These work in the same way as the `x` and `y` aesthetics, and are added into the call to `aes()`: 

* `aes(displ, hwy, color = class)`
* `aes(displ, hwy, shape = drv)`
* `aes(displ, hwy, size = cyl)`

`ggplot2` takes care of the details of converting data (e.g., 'f', 'r', '4') into aesthetics (e.g., 'red', 'yellow', 'green') with a __scale__. There is one scale for each aesthetic mapping in a plot. The scale is also responsible for creating a guide, an axis or legend, that allows you to read the plot, converting aesthetic values back into data values. For now, we'll stick with the default scales provided by `ggplot2`. 

To learn more about those outlying variables in the previous scatterplot, we could map the class variable to color:

```{r}

```

This gives each point a unique color corresponding to its class. The legend allows us to read data values from the color, showing us that the group of cars with unusually high fuel economy for their engine size are two seaters: cars with big engines, but lightweight bodies. 

If you want to set an aesthetic to a fixed value, without scaling it, do so in the individual layer outside of `aes()`.

```{r}

```

Here, __all__ the points are given the R color blue. 

Different types of aesthetic attributes work better with different types of variables. For example, color and shape work well with categorical variables, while size works well for continuous variables. The amount of data also makes a difference: if there is a lot of data it can be hard to distinguish different groups. An alternative solution is to use facetting, as described next.

When using aesthetics in a plot, less is usually more. It's difficult to see the simultaneous relationships among color and shape and size, so exercise restraint when using aesthetics. Instead of trying to make one very complex plot that shows everything at once, see if you can create a series of simple plots that tell a story, leading the reader from ignorance to knowledge.

### Exercise

Experiment with the color, shape and size aesthetics in the code block below. What happens when you map them to continuous values? What about categorical values? What happens when you use more than one aesthetic in a plot?

```{r}

```

## Facetting

Another technique for displaying additional categorical variables on a plot is facetting. Facetting creates tables of graphics by splitting the data into subsets and displaying the same graph for each subset. 

There are two types of facetting: grid and wrapped. Wrapped is the most useful, so we'll discuss it here, and you can learn about grid facetting later. To facet a plot you simply add a facetting specification with `facet_wrap()`, which takes the name of a variable preceded by `~`.

```{r}

```

### Exercise
  
Use facetting to explore the 3-way relationship between fuel economy, engine size, and number of cylinders. How does facetting by number of cylinders change your assessement of the relationship between engine size and fuel economy?

```{r}

```

## Plot geoms

You might guess that by substituting `geom_point()` for a different geom function, you'd get a different type of plot. That's a great guess! In the following sections, you'll learn about some of the other important geoms provided in `ggplot2`. This isn't an exhaustive list, but should cover the most commonly used plot types. 

* `geom_smooth()` fits a smoother to the data and displays the smooth and its standard error.

* `geom_boxplot()` produces a box-and-whisker plot to summarise the distribution of a set of points.

* `geom_histogram()` and `geom_freqpoly()` show the distribution of continuous variables.

* `geom_bar()` shows the distribution of categorical variables.

* `geom_path()` and `geom_line()` draw lines between the data points. A line plot is constrained to produce lines that travel from left to right, while paths can go in any direction. Lines are typically used to explore how things change over time.

### Adding a smoother to a plot 

If you have a scatterplot with a lot of noise, it can be hard to see the dominant pattern. In this case it's useful to add a smoothed line to the plot with `geom_smooth()`: 

```{r}

```

This overlays the scatterplot with a smooth curve, including an assessment of uncertainty in the form of point-wise confidence intervals shown in grey. If you're not interested in the confidence interval, turn it off with `geom_smooth(se = FALSE)`.

An important argument to `geom_smooth()` is the `method`, which allows you to choose which type of model is used to fit the smooth curve:

*   `method = "loess"`, the default for small n, uses a smooth local regression (as described in `?loess`). The wiggliness of the line is controlled by the `span` parameter, which ranges from 0 (exceedingly wiggly) to 1 (not so wiggly).
      
```{r}

```
      
Loess does not work well for large datasets (it's $O(n^2)$ in memory), so an alternative smoothing algorithm is used when $n$ is greater than 1,000. 

*   `method = "gam"` fits a generalised additive model provided by the __mgcv__ package. You need to first load mgcv, then use a formula like `formula = y ~ s(x)` or `y ~ s(x, bs = "cs")` (for large data). This is what `ggplot2` uses when there are more than 1,000 points. 

```{r}

```

*   `method = "lm"` fits a linear model, giving the line of best fit.     

```{r}

```

  * `method = "rlm"` works like `lm()`, but uses a robust fitting algorithm so that outliers don't affect the fit as much. It's part of the __MASS__ package, so remember to load that first.
  
```{r}

```

#### Exercise

In the code block below, create a scatterplot of the relationship between highway fuel economy and engine size with a smooth curve determined by the loess method, but remove the confidence interval and change the color of the smooth curve to red:

```{r}

```

### Boxplots and jittered points

When a set of data includes a categorical variable and one or more continuous variables, you will probably be interested to know how the values of the continuous variables vary with the levels of the categorical variable. Say we're interested in seeing how fuel economy varies within cars that have the same kind of drivetrain. We might start with a scatterplot like this:

```{r}

```

Because there are few unique values of both `drv` and `hwy`, there is a lot of overplotting. Many points are plotted in the same location, and it's difficult to see the distribution. There are three useful techniques that help alleviate the problem:

* Jittering, `geom_jitter()`, adds a little random noise to the data which can 
  help avoid overplotting. 
  
* Boxplots, `geom_boxplot()`, summarise the shape of the distribution
  with a handful of summary statistics. 
  
* Violin plots, `geom_violin()`, show a compact representation of the
  "density" of the distribution, highlighting the areas where more points
  are found.
  
These are illustrated below:

```{r}

```

Each method has its strengths and weaknesses. Boxplots summarise the bulk of the distribution with only five numbers, while jittered plots show every point but only work with relatively small datasets. Violin plots give the richest display, but rely on the calculation of a density estimate, which can be hard to interpret.

For jittered points, `geom_jitter()` offers the same control over aesthetics as `geom_point()`: `size`, `color`, and `shape`. For `geom_boxplot()` and `geom_violin()`, you can control the outline `color` or the internal `fill` color.

#### Exercise

Experiment with the color, shape and size aesthetics in the code block below. How would you create a jitter plot with points colored according to drivetrain with shapes corresponding to class? What about a violin plot with fill color corresponding to drivetrain?

```{r}

```

### Histograms and frequency polygons

Histograms and frequency polygons show the distribution of a single numeric variable. They provide more information about the distribution of a single group than boxplots do, at the expense of needing more space.

```{r}

```

Both histograms and frequency polygons work in the same way: they bin the data, then count the number of observations in each bin. The only difference is the display: histograms use bars and frequency polygons use lines. 

You can control the width of the bins with the `binwidth` argument (if you don't want evenly spaced bins you can use the `breaks` argument). It is __very important__ to experiment with the bin width. The default just splits your data into 30 bins, which is unlikely to be the best choice. You should always try many bin widths, and you may find you need multiple bin widths to tell the full story of your data.

```{r}

```

An alternative to the frequency polygon is the density plot, `geom_density()`. However, they are harder to interpret since the underlying computations are more complex. They also make assumptions that are not true for all data, namely that the underlying distribution is continuous, unbounded, and smooth.

To compare the distributions of different subgroups, you can map a categorical variable to either fill (for `geom_histogram()`) or color (for `geom_freqpoly()`). It's easier to compare distributions using the frequency polygon because the underlying perceptual task is easier. You can also use facetting: this makes comparisons a little harder, but it's easier to see the distribution of each group.

```{r}

```

#### Exercise

Experiment with the number of bins and binwidth in the code block below. Create a faceted histogram, as previously demonstrated, but this time change the number of bins to 50:

```{r}

```

### Bar charts

The discrete analogue of the histogram is the bar chart, `geom_bar()`. It's easy to use: 

```{r}

```

Bar charts can be confusing because there are two rather different plots that are both commonly called bar charts. The above form expects you to have unsummarised data, and each observation contributes one unit to the height of each bar. The other form of bar chart is used for presummarised data. For example, you might have three drugs with their average effect:

```{r}

```

To display this sort of data, you need to tell `geom_bar()` to not run the default stat which bins and counts the data. However, I think it's even better to use `geom_point()` because points take up less space than bars, and don't require that the y axis includes 0. 

```{r}

```

#### Exercise

In the code chunk below, create a bar plot which displays the number of cars in each class with fill color corresponding to the drivetrain distribution. What do you notice about 2-seater cars?

```{r}

```

### Time series with line and path plots

Line and path plots are typically used for time series data. Line plots join the points from left to right, while path plots join them in the order that they appear in the dataset (in other words, a line plot is a path plot of the data sorted by x value). Line plots usually have time on the x-axis, showing how a single variable has changed over time. Path plots show how two variables have simultaneously changed over time, with time encoded in the way that observations are connected.

Because the year variable in the `mpg` dataset only has two values, we'll show some time series plots using the `economics` dataset, which contains economic data on the US measured over the last 40 years. The figure below shows two plots of unemployment over time, both produced using `geom_line()`. The first shows the unemployment rate while the second shows the median number of weeks unemployed. We can already see some differences in these two variables, particularly in the last peak, where the unemployment percentage is lower than it was in the preceding peaks, but the length of unemployment is high. 

```{r}

```

To examine this relationship in greater detail, we would like to draw both time series on the same plot. We could draw a scatterplot of unemployment rate vs. length of unemployment, but then we could no longer see the evolution over time. The solution is to join points adjacent in time with line segments, forming a _path_ plot.

Below we plot unemployment rate vs. length of unemployment and join the individual observations with a path. Because of the many line crossings, the direction in which time flows isn't easy to see in the first plot. In the second plot, we color the points to make it easier to see the direction of time.

```{r}

```

We can see that unemployment rate and length of unemployment are highly correlated, but in recent years the length of unemployment has been increasing relative to the unemployment rate.

With longitudinal data, you often want to display multiple time series on each plot, each series representing one individual. To do this you need to map the `group` aesthetic to a variable encoding the group membership of each observation. 

In the example below, we’ll plot the time series of both unemployment and personal savings rates on the same graph. Our economics dataset is not arranged in a way that facilitates creating a multiple time series plot so we'll need to tidy and reshape our data. We'll do this by first creating a new dataframe which (1) calculates the unemployment rate, (2) collapses the unemployment rate and personal savings rate values into the same column, and (3) creates a grouping variable with the levels: psavert and unemploy_rate. To learn more about how to work with your data in this way, please attend our data wrangling workshop or check out the [RStudio Primers](https://rstudio.cloud/learn/primers).

```{r}

```

#### Exercise

Using the new dataframe you just created (`df`), create a multiple time series plot with different line colors for the two variables:

```{r}

```

## Modifying the axes

Two families of useful helpers let you make the most common axes modifications. `xlab()` and `ylab()` modify the x- and y-axis labels: 

```{r}

```

`xlim()` and `ylim()` modify the limits of axes: 

```{r}

```

Changing the axes limits sets values outside the range to `NA`. You can suppress the associated warning with `na.rm = TRUE`, but be careful. If your plot calculates summary statistics (e.g., sample mean), this conversion to `NA` occurs *before* the summary statistics are computed, and may lead to undesirable results in some situations.

### Exercise

Create a boxplot of highway fuel economy by drivetrain and modify the x- and y-labels to be more easily interpretable:

```{r}

```

## Output

Most of the time you create a plot object and immediately plot it, but you can also save a plot to a variable and manipulate it:

```{r}

```

Once you have a plot object, there are a few things you can do with it:

*   Render it on screen with `print()`. This happens automatically when running interactively, but inside a loop or function, you'll need to `print()` it yourself. 
    
```{r}

```
  
  * Save it to disk with `ggsave()`.
  
```{r}

```

  * Briefly describe its structure with `summary()`.
  
```{r}

```
    
  * Save a cached copy of it to disk, with `saveRDS()`. This saves a complete copy of the plot object, so you can easily re-create it with `readRDS()`.
    
```{r}

```

## Conclusion

Congratualions! You've now worked through "Getting started with ggplot2" from Hadley Wickham's book, [ggplot2: Elegant Graphics for Data Analysis](https://ggplot2-book.org/). Be sure to check out the other chapters for more advanced features of `ggplot2` and an in-depth discussion of the layered grammer of graphics.

As a final exercise, use the code block below to explore data visualizations that are meaningful to your own research. First visit the [ggplot2 reference website](https://ggplot2.tidyverse.org/reference/) and learn what dataset come build-in with `ggplot2`. Find one that is interesting to you and try your own unique visualizations by exploring the [R Graph Gallery](https://www.r-graph-gallery.com/), an extremely useful repository of data visualizations and the R code necessary to implement them.

```{r}

```

To further your learning be sure to check out these additional free(!) online resources:

- [From Data to Viz](https://www.data-to-viz.com/): Struggling to figure out which data visualization to use for your dataset? This decision tree will help you figure it out!
- [RStudio Primers](https://rstudio.cloud/learn/primers): A quick and dirty introduction to the tidyverse, a suite of data science packages that are engineered to play well together in R.
- [RStudio Cheat Sheets](https://rstudio.cloud/learn/cheat-sheets): Cheat sheets of the some most common tasks in R.  Print these out and hang them on your wall for quick reference!
- [R for Data Science book](https://r4ds.had.co.nz/): The defacto book for learning how to do data science in R (for good reason).
- [R Graphics Cookbook](https://r-graphics.org/): "Recipes" for all the data visualizations your heart desires!

You can also plug into a community of R enthusiasts within the GC and globally!

- [GC Digital Initiatives](https://gcdi.commons.gc.cuny.edu/calendar/): Keep an eye on the GCDI calendar to learn about user groups, workshops, office hours, and more!
- [R Users' Group](https://commons.gc.cuny.edu/groups/rug-r-users-group/): Working group at the GC focused on R... welcomes users of all skill levels!
- [R for Data Science Slack Group](https://www.rfordatasci.com/): Working through the R for Data Science book? Join this slack group to get help with all your questions!

